// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.3.0
// LVGL version: 8.3.6
// Project name: SuntonESP32_example

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <time.h>

#include "../ui.h"
#include "lvgl.h"
#include "segment_font.h"
#include "esp_system.h"
#include "esp_log.h"
#include "esp_spiffs.h"
#include "esp_heap_caps.h"
#include "esp_vfs_fat.h"
#include "nvs_flash.h"

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"


#define SINE_WAVE_LEN 60
#define SAW_WAVE_LEN 50
#define RECTANGLE_LEN 100

#define TAG "SPIFFS"
#define MAX_Y 65
#define MIN_Y -65
#define DATA_SIZE 600
#define MAX_DATA_SIZE 4096
char *wave_title[5] = {"SineWave", "SAW_WAVE", "RECTANGLE", "NOISE"};


int sine_wave[SINE_WAVE_LEN] = {0,5,10,15,20,25,29,33,37,40,43,45,47,48,49,50,49,48,47,45,43,40,37,33,29,25,20,15,10,5,0,-5,-10,-15,-20,-24,-29,-33,-37,-40,-43,-45,-47,-48,-49,-50,-49,-48,-47,-45,-43,-40,-37,-33,-29,-24,-20,-15,-10,-5};
int saw_wave[SAW_WAVE_LEN] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49};
int rectangle[RECTANGLE_LEN] = {50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50};

int selection_len;
int *selection_wave = NULL;
int selection_sine = 0;
int selection_idx = 0;
char graph_str[DATA_SIZE*5];
int backup[DATA_SIZE]={0,};
int radio_sel = -1;

bool chart_run = false;
lv_obj_t *chart;
lv_obj_t *time_label;
lv_chart_series_t * point;
static wl_handle_t s_wl_handle;
static SemaphoreHandle_t xSpiSemaphore;

void clear_chart() {
    static lv_style_t style_chart_main;
    static lv_style_t style_chart_serires;

    lv_style_init(&style_chart_main);
    lv_style_set_bg_color(&style_chart_main, lv_color_black());
    lv_style_set_line_color(&style_chart_main, lv_color_black());

    lv_style_init(&style_chart_serires);
    lv_style_set_line_width(&style_chart_serires, 2);
    //lv_style_set_radius(&style_chart_serires, 5);

    lv_obj_t *obj = lv_obj_get_parent(chart);
    lv_obj_del(chart);
    chart = lv_chart_create(obj);
    lv_obj_set_style_pad_all(chart, 3, LV_PART_MAIN);
    lv_obj_set_size(chart, LV_PCT(100), LV_PCT(90));
    lv_obj_align(chart, LV_ALIGN_TOP_LEFT, 0, 0);
    lv_chart_set_type(chart, LV_CHART_TYPE_LINE);
    lv_chart_set_point_count(chart, DATA_SIZE);
    lv_chart_set_range(chart, LV_CHART_AXIS_PRIMARY_X, 0, DATA_SIZE-1);
    lv_chart_set_range(chart, LV_CHART_AXIS_PRIMARY_Y, -100, 100);
    lv_obj_add_style(chart, &style_chart_main, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_add_style(chart, &style_chart_serires, LV_PART_ITEMS | LV_STATE_DEFAULT);
    lv_obj_set_style_size(chart, 0, LV_PART_INDICATOR);
    point = lv_chart_add_series(chart, lv_palette_main(LV_PALETTE_GREEN), LV_CHART_AXIS_PRIMARY_Y);
    memset(backup, 0, sizeof(backup));
    
    lv_chart_set_value_by_id(chart, point, 0, 0); // 모든 데이터 포인트를 0으로 설정
    
    lv_chart_refresh(chart); 
}
void update_chart(void) {
    static uint16_t index = 0;
    int random;
    
    if(chart_run) {
        if(selection_len == -1) {
            random = (rand() % 131) - 65;
            printf("random : %d\t", random);
            lv_chart_set_value_by_id(chart, point, index, random);
            backup[index] = random;
        } else {
            lv_chart_set_value_by_id(chart, point, index, selection_wave[selection_idx%selection_len]);
            backup[index] = selection_wave[selection_idx%selection_len];
            selection_idx++;  
        }
        lv_chart_refresh(chart);
        if(index >= DATA_SIZE-1) {
            clear_chart();
            index = 0;
        }
        index++;
    }
}
void update_timer(void) {
    static uint32_t time = 0;
    char time_str[16];
    if(chart_run) {
        time += 100;

        uint32_t total_seconds = time / 1000;
        uint32_t milliseconds = time % 1000;
        uint32_t seconds = total_seconds % 60;
        uint32_t minutes = (total_seconds / 60) % 60;
        uint32_t hours = (total_seconds / 3600);
        
        snprintf(time_str, sizeof(time_str), "%02lu:%02lu:%02lu:%02lu", hours, minutes, seconds, milliseconds/10);
        lv_label_set_text(time_label, time_str);
    }
}
void print_memory_usage()
{
    ESP_LOGI(TAG, "System Memory Info:");
    ESP_LOGI(TAG, "    Total free heap: %lu bytes", (unsigned long) esp_get_free_heap_size());
    ESP_LOGI(TAG, "    Largest free block: %lu bytes", (unsigned long) heap_caps_get_largest_free_block(MALLOC_CAP_8BIT));
    ESP_LOGI(TAG, "    Minimum free heap ever: %lu bytes", (unsigned long) esp_get_minimum_free_heap_size());

    multi_heap_info_t info;
    heap_caps_get_info(&info, MALLOC_CAP_8BIT);
    ESP_LOGI(TAG, "Heap Info (8-bit capable):");
    ESP_LOGI(TAG, "    Total size: %lu bytes", (unsigned long) (info.total_free_bytes + info.total_allocated_bytes));
    ESP_LOGI(TAG, "    Free size: %lu bytes", (unsigned long) info.total_free_bytes);
    ESP_LOGI(TAG, "    Allocated size: %lu bytes", (unsigned long) info.total_allocated_bytes);
    ESP_LOGI(TAG, "    Minimum free size ever: %lu bytes", (unsigned long) info.minimum_free_bytes);
}

// File System
void init_spiffs() {
    esp_vfs_spiffs_conf_t conf = {
        .base_path = "/spiffs",
        .partition_label = "storage",
        .max_files = 5,
        .format_if_mount_failed = false
    };

    esp_err_t ret = esp_vfs_spiffs_register(&conf);
    // esp_err_t ret = ESP_OK;
    if (ret != ESP_OK) {
        if (ret == ESP_FAIL) {
            ESP_LOGE(TAG, "Failed to mount or format filesystem");
        } else if (ret == ESP_ERR_NOT_FOUND) {
            ESP_LOGE(TAG, "Failed to find SPIFFS partition");
        } else {
            ESP_LOGE(TAG, "Failed to initialize SPIFFS (%s)", esp_err_to_name(ret));
        }
        return;
    }

    size_t total = 0, used = 0;
    ret = esp_spiffs_info("spiffs", &total, &used);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to get SPIFFS partition information (%s)", esp_err_to_name(ret));
    } else {
        ESP_LOGI(TAG, "Partition size: total: %d, used: %d", total, used);
    }
    ESP_LOGI(TAG, "SPIFFS mounted successfully");
}

void write_file(const char *path, const char *data, bool type) { // type0 = binary, type1 = text
    printf("Save text btn In\n");
    FILE *f = fopen(path, type ? "w" : "wb");
    if(f == NULL) {
        ESP_LOGE(TAG, "Failed to open file for writing");
        return;
    }

    if(!type) {
        size_t length = strlen(data);
        fwrite(data, sizeof(char), length, f);
    }
    else 
        fprintf(f, "%s", data);
    
    fclose(f);
    ESP_LOGI(TAG, "%s\n", data);
    ESP_LOGI(TAG, "File written successfully");
    lv_obj_invalidate(pulse_init_Screen);
}
void read_file(const char *path, lv_obj_t *textarea, bool type) { // type0 = binary, type1 = text
    FILE *f = fopen(path, type ? "r" : "rb");
    if(f == NULL) {
        ESP_LOGE(TAG, "Failed to open file for reading");
        return;
    }
    char *buffer = (char *)heap_caps_malloc(MAX_DATA_SIZE, MALLOC_CAP_SPIRAM);
    if (buffer == NULL) {
        ESP_LOGE(TAG, "Failed to allocate memory");
        fclose(f);
        return;
    }

    memset(buffer, 0, MAX_DATA_SIZE);
    
    if(!type) {
        size_t bytesRead = fread(buffer, 1, MAX_DATA_SIZE - 1, f);
        printf("bytesRead : %d\n", (int)bytesRead);
        if (bytesRead > 0) {
            buffer[bytesRead] = '\0';
            ESP_LOGI(TAG, "Binary file content: %s", buffer);
            clear_chart();

            char *token = strtok(buffer, ",");
            int idx = 0;
            while(token != NULL && idx < DATA_SIZE) {
                backup[idx] = atoi(token);
                // ESP_LOGE("FS", "idx: %d, value : %d, token : %d", idx, backup[idx], atoi(token));
                lv_chart_set_value_by_id(chart, point, idx, backup[idx]);
                token = strtok(NULL, ",");
                idx++;
            }
            // lv_chart_set_all_value(chart, point, (lv_coord_t *)backup);
            // lv_chart_set_ext_y_array(chart, point, (lv_coord_t *)backup);
            lv_chart_refresh(chart); 
        }
    } else {
        size_t totalBytesRead = 0;
        while (totalBytesRead < MAX_DATA_SIZE - 1 && fgets(buffer + totalBytesRead, MAX_DATA_SIZE - totalBytesRead, f)) {
            totalBytesRead += strlen(buffer + totalBytesRead);
        }
        buffer[totalBytesRead] = '\0'; // null terminator 추가
        lv_textarea_set_text(textarea, buffer);
    }
    
    free(buffer);
    fclose(f);
}

// File Save & Load Button
void save_text_btn_click(lv_event_t *e) {
    char temp_text[16];
    graph_str[0] = '\0';

    for(int i=0; i<DATA_SIZE; i++) {
        snprintf(temp_text, sizeof(temp_text), "%d", backup[i]);

        if(strlen(graph_str) + strlen(temp_text) +1 < sizeof(graph_str)) {
            strcat(graph_str, temp_text);
            if(i < DATA_SIZE-1)
                strcat(graph_str, ",");
        } else {
            break;
        }        
    }
    // write_to_file("/spiflash/test.txt", graph_str);
    write_file("/spiffs/test.txt", graph_str, true);
}
void load_text_btn_click(lv_event_t *e) {
    lv_obj_t *textarea = lv_event_get_user_data(e);
    printf("Load text btn In\n");
    // read_to_file("/spiflash/test.txt", textarea);
    read_file("/spiffs/test.txt", textarea, true);
}
void save_binary_btn_click(lv_event_t *e) {
    char temp_text[16];
    graph_str[0] = '\0';

    for(int i=0; i<DATA_SIZE; i++) {
        snprintf(temp_text, sizeof(temp_text), "%d", backup[i]);

        if(strlen(graph_str) + strlen(temp_text) +1 < sizeof(graph_str)) {
            strcat(graph_str, temp_text);
            if(i < DATA_SIZE-1)
                strcat(graph_str, ",");
        } else {
            break;
        }        
    }
    write_file("/spiffs/test.bin", graph_str, false);
}
void load_binary_btn_click(lv_event_t *e) {
    lv_obj_t *textarea = lv_event_get_user_data(e);
    printf("Load text btn In\n");
    read_file("/spiffs/test.bin", textarea, false);
}

void radio_selection_event(lv_event_t *e) {
    uint32_t *active_id = lv_event_get_user_data(e);
    lv_obj_t *cont = lv_event_get_current_target(e);
    lv_obj_t *act_cb = lv_event_get_target(e);
    lv_obj_t *old_cb;

    if(*active_id != -1) {
        old_cb = lv_obj_get_child(cont, *active_id);
        lv_obj_clear_state(old_cb, LV_STATE_CHECKED);
    }
    if(act_cb == cont) {
        *active_id = -1;
        return;
    }

    lv_obj_add_state(act_cb, LV_STATE_CHECKED);
    *active_id = lv_obj_get_index(act_cb);

    if(*active_id == 0) {
        selection_wave = sine_wave;
        selection_len = SINE_WAVE_LEN;
    } else if(*active_id == 1){
        selection_wave = saw_wave;
        selection_len = SAW_WAVE_LEN;
    } else if(*active_id == 2){
        selection_wave = rectangle;
        selection_len = RECTANGLE_LEN;
    } else if(*active_id == 3) {
        selection_len = -1;
    }

    ESP_LOGE("SEL", "selection : %d", selection_len);
    selection_idx = 0;
    ESP_LOGI("RADIO","active id: %d", (int)*active_id);
}
void make_radio_btn(lv_obj_t *screen, const char *title, lv_style_t *style_radio, lv_style_t *style_radio_chk) {
    lv_obj_t *obj = lv_checkbox_create(screen);
    lv_checkbox_set_text(obj, title);
    lv_obj_add_flag(obj, LV_OBJ_FLAG_EVENT_BUBBLE);
    lv_obj_add_style(obj, style_radio, LV_PART_INDICATOR);
    lv_obj_add_style(obj, style_radio_chk, LV_PART_INDICATOR | LV_STATE_CHECKED);
    
    lv_obj_set_flex_grow(obj, 1);
    ESP_LOGE("RADIO", "%s", title);
}

void chart_timer_callback(lv_timer_t * timer) {
    update_chart();
}
void timer_timer_callback(lv_timer_t *timer) {
    update_timer();
}
void start_btn_click(lv_event_t *e) {
    static lv_timer_t *chart_timer = NULL;
    static lv_timer_t *timer_timer = NULL;
    lv_obj_t *label = lv_event_get_user_data(e);
    
    if(radio_sel == -1)
        return;
    
    if(chart_run) {
        lv_label_set_text(label, "Start");
        chart_run = false;
    } else {
        lv_label_set_text(label, "Stop");
        if(chart_timer == NULL)
            chart_timer = lv_timer_create(chart_timer_callback, 50, NULL);
        if(timer_timer == NULL)
            chart_timer = lv_timer_create(timer_timer_callback, 100, NULL);
        chart_run = true;
    }
}

void for_text_btn_click(lv_event_t *e) {
    char temp_text[16];

    lv_obj_t *obj = lv_event_get_target(e);
    lv_obj_t *textarea = lv_event_get_user_data(e);

    graph_str[0] = '\0';

    for(int i=0; i<DATA_SIZE; i++) {
        snprintf(temp_text, sizeof(temp_text), "%d", backup[i]);

        if(strlen(graph_str) + strlen(temp_text) +1 < sizeof(graph_str)) {
            strcat(graph_str, temp_text);
            if(i < DATA_SIZE-1)
                strcat(graph_str, ",");
        } else {
            break;
        }        
    }
    lv_textarea_set_text(textarea, graph_str);
}
void clear_text_btn_click(lv_event_t *e) {
    // init_spiffs();
    lv_obj_t *obj = lv_event_get_target(e);
    lv_obj_t *textarea = lv_event_get_user_data(e);

    lv_textarea_set_text(textarea, "");
    // init_spiffs();
}
void print_font_info(const lv_font_t * font) {
    // 폰트가 NULL인지 확인
    if (font == NULL) {
        printf("Font is NULL\n");
        return;
    }

    // 폰트의 기본 정보 출력
    printf("Font Information:\n");
    printf("  - Line Height: %d\n", font->line_height);
    printf("  - Base Line: %d\n", font->base_line);

    // 버전 체크 후 추가 정보 출력
    #if LVGL_VERSION_MAJOR >= 8
    printf("  - Underline Position: %d\n", font->underline_position);
    printf("  - Underline Thickness: %d\n", font->underline_thickness);
    #endif

    // 글리프 정보 출력
    if (font->dsc) {
        const lv_font_fmt_txt_dsc_t * dsc = font->dsc;
        printf("  Glyph Bitmap:\n");
        printf("    - Number of Glyphs: %d\n", dsc->cmap_num);
        printf("    - Bitmap Format: %d\n", dsc->bitmap_format);
        printf("    - Bpp: %d\n", dsc->bpp);
        printf("    - Kerning Scale: %d\n", dsc->kern_scale);
        printf("    - Kerning Classes: %d\n", dsc->kern_classes);

        if (dsc->glyph_bitmap) {
            printf("    - Glyph Bitmap Address: %p\n", (void *)dsc->glyph_bitmap);
        }
        if (dsc->glyph_dsc) {
            printf("    - Glyph Description Address: %p\n", (void *)dsc->glyph_dsc);
        }
        if (dsc->cmaps) {
            printf("    - Cmaps Address: %p\n", (void *)dsc->cmaps);
        }
        if (dsc->kern_dsc) {
            printf("    - Kerning Descriptor Address: %p\n", (void *)dsc->kern_dsc);
        }
        if (dsc->cache) {
            printf("    - Glyph Cache Address: %p\n", (void *)dsc->cache);
        }
    } else {
        printf("Font description (dsc) is NULL\n");
    }
}

void design_init() {
    lv_obj_t *main = lv_obj_create(pulse_init_Screen);
    lv_obj_set_size(main, 800, 480);
    lv_obj_center(main);
    lv_obj_set_style_pad_all(main, 0, LV_PART_MAIN);
    lv_obj_set_flex_flow(main, LV_FLEX_FLOW_COLUMN);

    lv_obj_t *chartView = lv_obj_create(main);
    lv_obj_set_size(chartView, LV_PCT(100), LV_PCT(50));
    lv_obj_set_style_pad_all(chartView, 0, LV_PART_MAIN);
    // Chart Left Area
    lv_obj_t *chartView_left_area = lv_obj_create(chartView);
    lv_obj_set_style_pad_all(chartView_left_area, 0, LV_PART_MAIN);
    lv_obj_set_size(chartView_left_area, LV_PCT(80), LV_PCT(100));
    lv_obj_align(chartView_left_area, LV_ALIGN_TOP_LEFT, 5, 5);

    chart = lv_chart_create(chartView_left_area);
    clear_chart();
    
    lv_obj_t *start_btn = lv_btn_create(chartView_left_area);
    lv_obj_set_size(start_btn, LV_PCT(30), LV_PCT(10));
    lv_obj_align(start_btn, LV_ALIGN_BOTTOM_LEFT, 0, 0);
    lv_obj_t *start_btn_label = lv_label_create(start_btn);
    lv_label_set_text(start_btn_label, "Start");
    lv_obj_center(start_btn_label);
    lv_obj_add_event_cb(start_btn, start_btn_click, LV_EVENT_CLICKED, start_btn_label);

    lv_obj_t *radioarea = lv_obj_create(chartView_left_area);
    lv_obj_set_flex_flow(radioarea, LV_FLEX_FLOW_ROW);
    lv_obj_set_size(radioarea, LV_PCT(70), LV_PCT(10));
    lv_obj_set_style_pad_all(radioarea, 0, LV_PART_MAIN);
    lv_obj_align(radioarea, LV_ALIGN_BOTTOM_RIGHT, 0, 0);
    static lv_style_t style_radio;
    static lv_style_t style_radio_chk;
    lv_style_init(&style_radio);
    lv_style_init(&style_radio_chk);
    lv_style_set_radius(&style_radio, LV_RADIUS_CIRCLE);
    lv_style_set_bg_color(&style_radio_chk, lv_palette_main(LV_PALETTE_BLUE));
    lv_obj_add_event_cb(radioarea, radio_selection_event, LV_EVENT_CLICKED, &radio_sel);

    for(int idx = 0; idx < 4; idx++)
        make_radio_btn(radioarea, wave_title[idx], &style_radio, &style_radio_chk);
    

    // Chart Right Area
    lv_obj_t *chartView_right_area = lv_obj_create(chartView);
    lv_obj_set_size(chartView_right_area, LV_PCT(18), LV_PCT(100));
    lv_obj_align(chartView_right_area, LV_ALIGN_TOP_RIGHT, 5, 5);
    lv_obj_set_flex_flow(chartView_right_area, LV_FLEX_FLOW_COLUMN);

    lv_obj_t *textView = lv_obj_create(main);
    lv_obj_set_size(textView, LV_PCT(100), LV_PCT(47));
    lv_obj_set_style_pad_all(textView, 0, LV_PART_MAIN);

    // Text Left Area
    lv_obj_t *textView_left_area = lv_obj_create(textView);
    lv_obj_set_size(textView_left_area, LV_PCT(80), LV_PCT(100));
    lv_obj_align(textView_left_area, LV_ALIGN_TOP_LEFT, 0, 0);
    lv_obj_set_style_pad_all(textView_left_area, 0, LV_PART_MAIN);

    lv_obj_t *textarea = lv_textarea_create(textView_left_area);
    lv_obj_set_size(textarea, LV_PCT(100), LV_PCT(80));
    lv_obj_align(textarea, LV_ALIGN_BOTTOM_LEFT, 0, 0);

    // 순서 좀 바꿈 (charView 자식 객체)
    lv_obj_t *binary_save_btn = lv_btn_create(chartView_right_area);
    lv_obj_set_size(binary_save_btn, LV_PCT(100), LV_PCT(35));
    lv_obj_center(binary_save_btn);
    lv_obj_add_event_cb(binary_save_btn, save_binary_btn_click, LV_EVENT_CLICKED, textarea);
    lv_obj_t *binary_save_btn_label = lv_label_create(binary_save_btn);
    lv_label_set_text(binary_save_btn_label, "Save Binary");
    lv_obj_center(binary_save_btn_label);

    lv_obj_t *binary_open_btn = lv_btn_create(chartView_right_area);
    lv_obj_set_size(binary_open_btn, LV_PCT(100), LV_PCT(35));
    lv_obj_center(binary_open_btn);
    lv_obj_add_event_cb(binary_open_btn, load_binary_btn_click, LV_EVENT_CLICKED, textarea);
    lv_obj_t *binary_open_btn_label = lv_label_create(binary_open_btn);
    lv_label_set_text(binary_open_btn_label, "Open Binary");
    lv_obj_center(binary_open_btn_label);



    lv_obj_t *for_text_btn = lv_btn_create(textView_left_area);
    lv_obj_set_size(for_text_btn, LV_PCT(30), LV_PCT(15));
    lv_obj_align(for_text_btn, LV_ALIGN_TOP_LEFT, 0, 0);
    lv_obj_add_event_cb(for_text_btn, for_text_btn_click, LV_EVENT_CLICKED, textarea);
    lv_obj_t *for_text_btn_label = lv_label_create(for_text_btn);
    lv_label_set_text(for_text_btn_label, "For Text");
    lv_obj_center(for_text_btn_label);

    lv_obj_t *clear_text_btn = lv_btn_create(textView_left_area);
    lv_obj_set_size(clear_text_btn, LV_PCT(30), LV_PCT(15));
    lv_obj_align(clear_text_btn, LV_ALIGN_TOP_LEFT, LV_PCT(30) + 3, 0);
    lv_obj_add_event_cb(clear_text_btn, clear_text_btn_click, LV_EVENT_CLICKED, textarea);
    lv_obj_t *clear_text_btn_label = lv_label_create(clear_text_btn);
    lv_label_set_text(clear_text_btn_label, "Clear");
    lv_obj_center(clear_text_btn_label);

    // Text Right Area
    lv_obj_t *textView_right_area = lv_obj_create(textView);
    lv_obj_set_size(textView_right_area, LV_PCT(18), LV_PCT(100));
    lv_obj_align(textView_right_area, LV_ALIGN_TOP_RIGHT, 5, 5);
    lv_obj_set_flex_flow(textView_right_area, LV_FLEX_FLOW_COLUMN);

    time_label = lv_label_create(textView_right_area);
    lv_obj_set_size(time_label, LV_PCT(100), LV_PCT(30));
    lv_obj_center(time_label);
    lv_label_set_text(time_label, "00:00:00:00");
    lv_obj_set_style_pad_all(time_label, 0, LV_PART_MAIN);
    // lv_obj_set_style_text_font(time_label, &segment_font, 0);
    print_font_info(&segment_font);


    lv_obj_t *text_save_btn = lv_btn_create(textView_right_area);
    lv_obj_set_size(text_save_btn, LV_PCT(100), LV_PCT(35));
    lv_obj_center(text_save_btn);
    lv_obj_add_event_cb(text_save_btn, save_text_btn_click, LV_EVENT_CLICKED, textarea);
    lv_obj_t *text_save_btn_label = lv_label_create(text_save_btn);
    lv_label_set_text(text_save_btn_label, "Save Text");
    lv_obj_center(text_save_btn_label);

    lv_obj_t *text_open_btn = lv_btn_create(textView_right_area);
    lv_obj_set_size(text_open_btn, LV_PCT(100), LV_PCT(35));
    lv_obj_center(text_open_btn);
    lv_obj_add_event_cb(text_open_btn, load_text_btn_click, LV_EVENT_CLICKED, textarea);
    lv_obj_t *text_open_btn_label = lv_label_create(text_open_btn);
    lv_label_set_text(text_open_btn_label, "Open Text");
    lv_obj_center(text_open_btn_label);

    lv_obj_set_flex_align(chartView, LV_ALIGN_CENTER, LV_ALIGN_CENTER, LV_ALIGN_CENTER);
    lv_obj_set_flex_align(textView, LV_ALIGN_CENTER, LV_ALIGN_CENTER, LV_ALIGN_CENTER);
}

void spiffs_init_task(void *pvParameter) {
    //init_spiffs();  // SPIFFS 초기화 함수 호출
    // SPIFFS 초기화가 완료된 후 UI 업데이트
    xTaskNotifyGive((TaskHandle_t)pvParameter);  // 메인 스레드에 알림
    vTaskDelete(NULL);  // 작업 완료 후 스레드 종료
}

void pulse_Screen_init(void) {

    init_spiffs();
    srand(time(NULL));
    printf("============================\n");
    pulse_init_Screen = lv_obj_create(NULL);
    lv_obj_clear_flag(pulse_init_Screen, LV_OBJ_FLAG_SCROLLABLE);
    // heap_caps_print_heap_info(MALLOC_CAP_DEFAULT);
    design_init(pulse_init_Screen);
    print_memory_usage();
    // print_memory_usage();
    //xTaskCreate(spiffs_init_task, "spiffs_init_task", 4096, NULL, 5, NULL);

    // TaskHandle_t spiffs_task_handle;
    // xTaskCreate(spiffs_init_task, "spiffs_init_task", 8192, (void*)&spiffs_task_handle, 5, &spiffs_task_handle);
    // ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
    // design_init(pulse_init_Screen);
    // lv_refr_now(NULL);
}