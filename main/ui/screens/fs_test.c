// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.3.0
// LVGL version: 8.3.6
// Project name: SuntonESP32_example

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <time.h>

#include "../ui.h"
#include "lvgl.h"
#include "segment_font.h"
#include "esp_system.h"
#include "esp_log.h"
#include "esp_spiffs.h"
#include "esp_heap_caps.h"
#include "esp_vfs_fat.h"
#include "nvs_flash.h"
#include "esp_lcd_panel_rgb.h"

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"


#define SINE_WAVE_LEN 60
#define SAW_WAVE_LEN 50
#define RECTANGLE_LEN 100

#define TAG "SPIFFS"
#define MAX_Y 65
#define MIN_Y -65
#define DATA_SIZE 600

int selection_len;
int *selection_wave = NULL;
int selection_sine = 0;
int selection_idx = 0;
char graph_str[DATA_SIZE*4];
int backup[DATA_SIZE]={0,};
int radio_sel = -1;

bool chart_run = false;
lv_obj_t *chart;
lv_obj_t *time_label;
lv_chart_series_t * point;
static wl_handle_t s_wl_handle;

void ui_init_two(void);
static void* fs_open(lv_fs_drv_t* drv, const char* path, lv_fs_mode_t mode)
{
    const char* flags = "";
    if(mode == LV_FS_MODE_WR) flags = "w";
    else if(mode == LV_FS_MODE_RD) flags = "r";
    else if(mode == (LV_FS_MODE_WR | LV_FS_MODE_RD)) flags = "r+";

    // Remove the leading 'S:' if present
    if (path[0] == 'S' && path[1] == ':') {
        path += 2;
    }

    char buf[256];
    snprintf(buf, sizeof(buf), "%s%s", "/spiffs", path);
    
    FILE* f = fopen(buf, flags);
    if(f == NULL) {
        ESP_LOGE("fs_open", "Failed to open file: %s", buf);
    }
    
    return (void*)f;
}
static lv_fs_res_t fs_close(lv_fs_drv_t* drv, void* file_p)
{
    fclose((FILE*)file_p);
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_read(lv_fs_drv_t* drv, void* file_p, void* buf, uint32_t btr, uint32_t* br)
{
    *br = fread(buf, 1, btr, (FILE*)file_p);
    return (*br <= 0) ? LV_FS_RES_UNKNOWN : LV_FS_RES_OK;
}

static lv_fs_res_t fs_write(lv_fs_drv_t* drv, void* file_p, const void* buf, uint32_t btw, uint32_t* bw)
{
    *bw = fwrite(buf, 1, btw, (FILE*)file_p);
    return (*bw <= 0) ? LV_FS_RES_UNKNOWN : LV_FS_RES_OK;
}

static lv_fs_res_t fs_seek(lv_fs_drv_t* drv, void* file_p, uint32_t pos, lv_fs_whence_t whence)
{
    int w;
    if(whence == LV_FS_SEEK_SET) w = SEEK_SET;
    else if(whence == LV_FS_SEEK_CUR) w = SEEK_CUR;
    else if(whence == LV_FS_SEEK_END) w = SEEK_END;
    else return LV_FS_RES_INV_PARAM;

    fseek((FILE*)file_p, pos, w);
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_tell(lv_fs_drv_t* drv, void* file_p, uint32_t* pos_p)
{
    *pos_p = ftell((FILE*)file_p);
    return LV_FS_RES_OK;
}

static void lvgl_fs_init(void)
{
    esp_vfs_spiffs_conf_t conf = {
        .base_path = "/spiffs",
        .partition_label = "storage",
        .max_files = 5,
        .format_if_mount_failed = true
    };

    esp_err_t ret = esp_vfs_spiffs_register(&conf);
    if (ret != ESP_OK) {
        if (ret == ESP_FAIL) {
            ESP_LOGE("init", "Failed to mount or format filesystem\n");
        } else if (ret == ESP_ERR_NOT_FOUND) {
            ESP_LOGE("init", "Failed to find SPIFFS partition\n");
        } else {
            ESP_LOGE("init", "Failed to initialize SPIFFS (%s)\n", esp_err_to_name(ret));
        }
        return;
    }

    static lv_fs_drv_t fs_drv;
    lv_fs_drv_init(&fs_drv);

    fs_drv.letter = 'S';
    fs_drv.open_cb = fs_open;
    fs_drv.close_cb = fs_close;
    fs_drv.read_cb = fs_read;
    fs_drv.write_cb = fs_write;
    fs_drv.seek_cb = fs_seek;
    fs_drv.tell_cb = fs_tell;

    lv_fs_drv_register(&fs_drv);
    ESP_LOGE("init", "Mount to initialize SPIFFS");
    vTaskDelete(NULL);
}


void write_file(const char *path, const char *data, bool type) { // type0 = binary, type1 = text
    // lv_fs_file_t f;
    // lv_fs_res_t res;

    // res = lv_fs_open(&f, path, LV_FS_MODE_WR);
    // if(res != LV_FS_RES_OK) {
    //     ESP_LOGE("FS","Failed to open file for writing");
    //     return;
    // }
    // size_t bytes_written = lv_fs_write(&f, data, strlen(data), NULL);
    // if (bytes_written != strlen(data)) {
    //     printf("Failed to write data to file\n");
    // }
    
    // lv_fs_close(&f);
    printf("Save text btn In\n");
    FILE *f = fopen(path, type ? "w" : "wb");
    if(f == NULL) {
        ESP_LOGE(TAG, "Failed to open file for writing");
        return;
    }

    if(!type) {
        size_t length = strlen(data);
        fwrite(data, sizeof(char), length, f);
    }
    else 
        fprintf(f, "%s", data);
    
    fclose(f);
    ESP_LOGI(TAG, "File written successfully");
    lv_obj_invalidate(pulse_init_Screen);
}
void read_file(const char *path, lv_obj_t *textarea, bool type) { // type0 = binary, type1 = text
    FILE *f = fopen(path, type ? "r" : "rb");
    if(f == NULL) {
        ESP_LOGE(TAG, "Failed to open file for reading");
        return;
    }
    char *buffer = (char *)heap_caps_malloc(sizeof(graph_str) + 1, MALLOC_CAP_SPIRAM);
    // fseek(f, 0, SEEK_END);
    // size_t file_size = ftell(f);
    // fseek(f, 0, SEEK_SET);
    // char *psram_buffer = (char *)heap_caps_malloc(file_size + 1, MALLOC_CAP_SPIRAM);
    // ESP_LOGI("PSRAM", "File content read into file_size: %d", (int)file_size);
    // if(psram_buffer == NULL) {
    //     ESP_LOGE("PSRAM", "Failed to allocate memory from PSRAM");
    //     fclose(f);
    //     return;
    // }
    // size_t bytes_read = fread(psram_buffer, 1, file_size, f);
    // if(bytes_read != file_size) {
    //     ESP_LOGE("PSRAM", "Failed to read the complete file");
    //     free(psram_buffer);
    //     fclose(f);
    //     return;
    // }
    // psram_buffer[file_size] = '\0';
    // ESP_LOGI("PSRAM", "File content read into file_size: %d", (int)bytes_read);
    // ESP_LOGI("PSRAM", "File content read into PSRAM: %s", psram_buffer);
    // free(psram_buffer);
    // fclose(f);

    // if(type) {
    //     if (buffer == NULL) {
    //         ESP_LOGE(TAG, "Failed to allocate memory from PSRAM");
    //         fclose(f);
    //         return;
    //     }

    //     fread(buffer, 1, sizeof(graph_str), f);
    //     buffer[sizeof(graph_str)] = '\0';  // Null-terminate

    //     // 파일 내용 처리
    //     ESP_LOGI(TAG, "File content: %s", buffer);
    // }

    if(!type) {
        size_t bytesRead = fread(graph_str, 1, sizeof(graph_str) - 1, f); // null terminator를 위한 공간
        if (bytesRead > 0) {
            graph_str[bytesRead] = '\0'; // 문자열의 끝에 null terminator 추가 
            ESP_LOGI(TAG, "Binary file content (first 50 bytes): %.*s", 50, graph_str); // 첫 50바이트 출력
        }
    } else {
        while(fgets(graph_str, sizeof(graph_str), f)) {
            ESP_LOGI(TAG, "File content: %s", graph_str);
        }
    }
    lv_textarea_set_text(textarea, buffer);
    free(buffer);
    fclose(f);
    lv_obj_invalidate(pulse_init_Screen);

    // lv_fs_file_t f;
    // lv_fs_res_t res;
    // // lv_fs_res_t res;
    // // lv_obj_t *file;
    // char buffer[128];
    // size_t bytes_read;

    // res = lv_fs_open(&f, path, LV_FS_MODE_RD);
    // if (res != LV_FS_RES_OK) {
    //     printf("Failed to open file for reading\n");
    //     return;
    // }

    // // 데이터 읽기
    // bytes_read = lv_fs_read(&f, buffer, sizeof(buffer) - 1, NULL);
    // if (bytes_read > 0) {
    //     buffer[bytes_read] = '\0'; // 문자열 종료
    //     printf("Read data: %s\n", buffer);
    // } else {
    //     printf("Failed to read data from file\n");
    // }

    // // 파일 닫기
    // lv_fs_close(&f);
}

void init_fs() {
    esp_err_t ret = nvs_flash_init();
    if(ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    esp_vfs_fat_mount_config_t mount_config = {
        .format_if_mount_failed = true,
        .max_files = 1,
        .allocation_unit_size = CONFIG_WL_SECTOR_SIZE
    };

    ret = esp_vfs_fat_spiflash_mount("/spiflash", "storage", &mount_config, &s_wl_handle);
    if(ret != ESP_OK) {
        ESP_LOGE("FS", "Failed to mount FATFS (%s)", esp_err_to_name(ret));
        return;
    }
    ESP_LOGI("FS", "Filesystem mounted");
}

void write_to_file(const char *file, const char *data)  {
    FILE *f = fopen(file, "w");
    if(f == NULL) {
        ESP_LOGE("FS", "Failed to open file for writing");
        return;
    }
    fprintf(f, "%s", data);
    fclose(f);

    ESP_LOGI("FS", "File written: %s", file);
}
void read_to_file(const char *file) {
    FILE *f = fopen(file, "r");
    if(f == NULL) {
        ESP_LOGE("FS", "Failed to open file for reading");
        return;
    }
    char line[256];
    while(fgets(line, sizeof(line), f) != NULL) {
        ESP_LOGI("FS", "Read from file: %s", line);
    }
    fclose(f);
}


// File Save & Load Button

void print_heap_info() {
    heap_caps_print_heap_info(MALLOC_CAP_8BIT);
}
void init_spiffs() {
    esp_vfs_spiffs_conf_t conf = {
        .base_path = "/spiffs",
        .partition_label = "storage",
        .max_files = 2,
        .format_if_mount_failed = false
    };

    esp_err_t ret = esp_vfs_spiffs_register(&conf);
    // esp_err_t ret = ESP_OK;
    if (ret != ESP_OK) {
        if (ret == ESP_FAIL) {
            ESP_LOGE(TAG, "Failed to mount or format filesystem");
        } else if (ret == ESP_ERR_NOT_FOUND) {
            ESP_LOGE(TAG, "Failed to find SPIFFS partition");
        } else {
            ESP_LOGE(TAG, "Failed to initialize SPIFFS (%s)", esp_err_to_name(ret));
        }
        return;
    }

    size_t total = 0, used = 0;
    ret = esp_spiffs_info("spiffs", &total, &used);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to get SPIFFS partition information (%s)", esp_err_to_name(ret));
    } else {
        ESP_LOGI(TAG, "Partition size: total: %d, used: %d", total, used);
    }
    ESP_LOGI(TAG, "SPIFFS mounted successfully");
}

void save_text_file(const char* filename, const char* content) {
    lv_fs_file_t file;
    lv_fs_res_t res = lv_fs_open(&file, filename, LV_FS_MODE_WR);
    if (res != LV_FS_RES_OK) {
        printf("Failed to open file for writing\n");
        return;
    }

    uint32_t bytes_written;
    res = lv_fs_write(&file, content, strlen(content), &bytes_written);
    if (res != LV_FS_RES_OK || bytes_written != strlen(content)) {
        printf("Failed to write to file\n");
    }

    lv_fs_close(&file);
}

// Function to read a text file
char* read_text_file(const char* filename) {
    lv_fs_file_t file;
    lv_fs_res_t res = lv_fs_open(&file, filename, LV_FS_MODE_RD);
    if (res != LV_FS_RES_OK) {
        printf("Failed to open file for reading\n");
        return NULL;
    }

    uint32_t file_size;
    
    // 파일의 끝으로 이동
    res = lv_fs_seek(&file, 0, LV_FS_SEEK_END);
    if (res != LV_FS_RES_OK) {
        printf("Failed to seek to end of file\n");
        lv_fs_close(&file);
        return NULL;
    }
    
    // 현재 위치(파일의 크기)를 얻음
    res = lv_fs_tell(&file, &file_size);
    if (res != LV_FS_RES_OK) {
        printf("Failed to get file size\n");
        lv_fs_close(&file);
        return NULL;
    }
    
    // 파일 포인터를 다시 처음으로 이동
    res = lv_fs_seek(&file, 0, LV_FS_SEEK_SET);
    if (res != LV_FS_RES_OK) {
        printf("Failed to seek back to start of file\n");
        lv_fs_close(&file);
        return NULL;
    }

    char* buffer = malloc(file_size + 1);
    if (!buffer) {
        printf("Failed to allocate memory\n");
        lv_fs_close(&file);
        return NULL;
    }

    uint32_t bytes_read;
    res = lv_fs_read(&file, buffer, file_size, &bytes_read);
    if (res != LV_FS_RES_OK || bytes_read != file_size) {
        printf("Failed to read file\n");
        free(buffer);
        lv_fs_close(&file);
        return NULL;
    }

    buffer[file_size] = '\0';
    lv_fs_close(&file);
    return buffer;
}

void save_text_btn_click(lv_event_t *e) {
    ESP_LOGI("save", "save in");
    save_text_file("S:/example.txt", "Hello, LVGL!");
}

void load_text_btn_click(lv_event_t *e) {
    ESP_LOGI("load", "load in");
    char* text_content = read_text_file("S:/example.txt");
    if (text_content) {
        printf("Read text: %s\n", text_content);
        free(text_content);
    }
}
void ui_init_two(void) {
    fs_test_Screen = lv_obj_create(NULL);
    lv_obj_clear_flag(fs_test_Screen, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_flex_flow(fs_test_Screen, LV_FLEX_FLOW_COLUMN);
    print_heap_info();
    lv_obj_t *btn_a = lv_btn_create(fs_test_Screen);
    lv_obj_t *btn_a_label = lv_label_create(btn_a);
    lv_obj_center(btn_a_label);
    lv_label_set_text(btn_a_label, "Write");
    lv_obj_add_event_cb(btn_a, save_text_btn_click, LV_EVENT_CLICKED, NULL);

    lv_obj_t *btn_b = lv_btn_create(fs_test_Screen);
    lv_obj_t *btn_b_label = lv_label_create(btn_b);
    lv_obj_center(btn_b_label);
    lv_label_set_text(btn_b_label, "Read");
    lv_obj_add_event_cb(btn_b, load_text_btn_click, LV_EVENT_CLICKED, NULL); 
}

void fs_test_Screen_init(void) {
    // print_heap_info();
    // init_spiffs();
    // print_heap_info();
    init_spiffs();
    ui_init_two();
}